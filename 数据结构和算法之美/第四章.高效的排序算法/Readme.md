# 高效的排序算法
[toc]
## 分析待排序的数组的有序度
> 逆序度 = 满有序度 - 有序度。
> 我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。
## 原地排序算法
冒泡排序、插入排序、选择排序这三种排序算法，它们的时间复杂度都是 O(n2)，比较高，适合小规模数据的排序
|   | 是否原地排序  |是否是稳定  | 最好 最坏 平均 |
|---|---|---|---|
|  冒泡排序 |  Y | Y | O(n) O(n2) O(n2) |
|  插入排序 |  Y | Y | O(n) O(n2) O(n2) |
|  选择排序 |  Y | N | O(n2) O(n2) O(n2) |
>这三种时间复杂度为 O(n2) 的排序算法中，**冒泡排序、选择排序，可能就纯粹停留在理论的层面了**，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是**插入排序还是挺有用的。后面讲排序优化的时候，有些编程语言中的排序函数的实现原理会用到插入排序算法。**

### 冒泡算法
### 插入排序
>如果你对插入排序的优化感兴趣，可以自行学习一下希尔排序。
### 选择排序
## 大规模的数据排序
两种时间复杂度为 O(nlogn) 的排序算法，归并排序和快速排序。这两种排序算法适合大规模的数据排序
**归并排序和快速排序都用到了分治思想.**

### 归并排序
>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。
### 快速排序
>排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。
>默认最后一个为分区点
解决相关问题：
- 如何用快排思想在O(n)内查找第K大元素？

## 线性排序
桶排序、计数排序、基数排序，因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作线性排序（Linear sort）。之所以能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。
### 桶排序（Bucket sort）
>首先，我们来看桶排序。桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

使用场景：
- **桶排序比较适合用在外部排序中**。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

### 计数排序（Counting sort）
> 计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

流程：
1. 获取原先的数组: A = [2，5，3，0，2，3，0，3]
2. 生产桶存储个数的数组： C = [2, 0, 2, 3, 0 ,1]
3. 用C转换为总数转化数组： S = [2, 2, 4, 7, 7 ,8]
4. 生成排序的数组：R = [0] * 8
5. 循环A获取值k, 获取k在S中的值，代表小于等于k的数有S[k]个， -》 R[S[K] - 1] = K
6. 直到结果完

使用场景：
>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

解决相关问题：
- 每个分数的考生在有序数组中对应的存储位置呢

### 基数排序（Radix sort）
>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。