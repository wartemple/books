# 字符串匹配
## BF匹配（Brute Force）
> 模式串在主串中遍历匹配，对比子串和模式串，对比方法也是遍历
## RK匹配（Rain-Karp）
> 对子串求hash值，对比时，用hash值和子串的hash匹配即可
RK算法有两个可以改进的点，一个可以避免hash冲突，另一个可以减少hash计算次数。
- 先计算模式串的hash值，记录下来，然后计算每一个子串的hash，计算一次，就对比一次，如果hash值匹配，在全量对比字符串。这样做可以不用关心hash冲突问题。
- 计算子串hash值的时候只要计算到n-（n-m）处即可，剩下的子串长度小于模式串，不用计算。

## BM算法
> BM 算法的模式串和子串的比较从后往前匹配，这样可以加快匹配的速度，

### BM 算法包含两部分，分别是坏字符规则（bad character rule）和好后缀规则（good suffix shift）
- **坏字符规则：**
```
从后往前判断子串中是否有模式串中不存在的字符串,
不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。
如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。
```
> 注意，我这里说的下标，都是字符在模式串的下标。

- **好后缀规则：**
```
从后往前判断子串中和模式串后缀相互匹配的部分字符串：acbc和adbc
我们把已经匹配的 bc 叫作好后缀，记作{u}。
我们拿它在模式串中查找
- 如果找到了另一个跟{u}相匹配的子串{u*}，那我们就将模式串滑动到子串{u*}与主串中{u}对齐的位置。
- 如果在模式串中找不到另一个等于{u}的子串，我们就直接将模式串，滑动到主串中{u}的后面
- 考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。u-v
```

### 代码实现步骤
1. 坏字符串的在模式串中的位置求值？
- 遍历查找（不推荐）
- 提前处理缓存好字符的下标位置，用hashmap进行提前存储（字典啥的）
1. 匹配字串时，判断坏字符串的位置
2. 判断坏字符串在模式串的位置
3. 获取平移的长度 = 模式串的位置 - 主串的位置
4. 开始平移，在原有的基础上进行模式串平移（i的挪动）
5. 缓存模式串中的所有后缀字串：数组存储（index为后缀字串长度，value为模式串中最前方的索引位置）
6. 缓存后缀字串能不能匹配前缀字串，存储一个bool值

## KMP算法
在BM算法的基础上，新增算法向后多滑动几位。
### 优化方法
- 拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的


## Trie 树
> Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起

```
节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。
```
### 常用操作
1. 插入一个字符串
2. 查询一个字符串

**Trie 树比较适合的是查找前缀匹配的字符串**

Trie 树的这个应用可以扩展到更加广泛的一个应用上，就是自动输入补全，比如输入法自动补全功能、IDE 代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等

## 经典的多模式串匹配算法：AC 自动机(需要了解KMP算法)
```
AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了
```

### AC 自动机的构建
- 将多个模式串构建成 Trie 树
- 在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）
