# 字符串匹配
## BF匹配（Brute Force）
> 模式串在主串中遍历匹配，对比子串和模式串，对比方法也是遍历
## RK匹配（Rain-Karp）
> 对子串求hash值，对比时，用hash值和子串的hash匹配即可
RK算法有两个可以改进的点，一个可以避免hash冲突，另一个可以减少hash计算次数。
- 先计算模式串的hash值，记录下来，然后计算每一个子串的hash，计算一次，就对比一次，如果hash值匹配，在全量对比字符串。这样做可以不用关心hash冲突问题。
- 计算子串hash值的时候只要计算到n-（n-m）处即可，剩下的子串长度小于模式串，不用计算。

## BM算法
> BM 算法的模式串和子串的比较从后往前匹配，这样可以加快匹配的速度，

### BM 算法包含两部分，分别是坏字符规则（bad character rule）和好后缀规则（good suffix shift）
- **坏字符规则：**
```
从后往前判断子串中是否有模式串中不存在的字符串,
不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。
如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。
```
> 注意，我这里说的下标，都是字符在模式串的下标。

- **好后缀规则：**
```
从后往前判断子串中和模式串后缀相互匹配的部分字符串：acbc和adbc
我们把已经匹配的 bc 叫作好后缀，记作{u}。
我们拿它在模式串中查找
- 如果找到了另一个跟{u}相匹配的子串{u*}，那我们就将模式串滑动到子串{u*}与主串中{u}对齐的位置。
- 如果在模式串中找不到另一个等于{u}的子串，我们就直接将模式串，滑动到主串中{u}的后面
- 考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。u-v
```

### 代码实现步骤
1. 坏字符串的在模式串中的位置求值？
- 遍历查找（不推荐）
- 提前处理缓存好字符的下标位置，用hashmap进行提前存储（字典啥的）
1. 匹配字串时，判断坏字符串的位置
2. 判断坏字符串在模式串的位置
3. 获取平移的长度 = 模式串的位置 - 主串的位置
4. 开始平移，在原有的基础上进行模式串平移（i的挪动）
5. 缓存模式串中的所有后缀字串：数组存储（index为后缀字串长度，value为模式串中最前方的索引位置）
6. 缓存后缀字串能不能匹配前缀字串，存储一个bool值

## KMP算法
在BM算法的基础上，新增算法向后多滑动几位。
### 优化方法
- 拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的
