# 哈希表

[toc]

> 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

> 散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

## 散列冲突

> 再好的散列函数也无法避免散列冲突。那究竟该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。

### 1. 开放寻址法

开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？

> 我们用装载因子（load factor）来表示空位的多少， 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

元素个数 / 数组长度 = 装载因子

#### 线性探测（Linear Probing）

某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

#### 二次探测（Quadratic probing）

所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……

#### 双重散列（Double hashing）

所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。

### 2. 链表法

> 链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中

## 问题解决

单词拼写检查的功能实现

```
常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，
那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。
对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。
当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。
如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。
借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。
```

# 哈希表的进阶-完美的 hash 函数

**_DoS(拒绝服务攻击)的一种方式——散列表的碰撞攻击： 当 hashMap 基于链表构造时，黑客可以通过精心准备的数据，使得哈希后都存放在同一个槽里（全部遭遇哈希冲突），使 hashMap 退化为链表_**

## hash 函数要求

-   **散列函数的设计不能太复杂**： 过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能。
-   **散列函数生成的值要尽可能随机并且均匀分布**：这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。

## hash 表其他功能

-   支持动态扩容，但避免低效扩容
-   支持共同维护多个 hash 表，将扩容的时间复杂平摊到每一次的插入中。当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。
    这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。

## 冲突解决方案对比

### 开放寻址法

**优点**

```
 1. 散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。
 2. 这种方法实现的散列表，序列化起来比较简单
```

**缺点**

```
用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。
而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。
所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。
```

**总结**

```
当数据量比较小、装载因子小的时候，适合采用开放寻址法
```

### 链表法

**优点**

```
 1. 链表法对内存的利用率比开放寻址法要高。
 2. 链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。
```

**缺点**

```
链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。
而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。

如果我们存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。
```

**总结**

```
基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。
```
